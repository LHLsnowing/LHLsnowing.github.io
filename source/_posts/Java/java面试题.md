---
title: Java面试题
top: false
cover: false
toc: true
mathjax: true
date: 2023-07-16 13:20:50
summary: 记录一些java面试题
tags: [Java,Java面试题]
categories: [Java,Java面试题]
---

## 一、
### 1.Java 语言的特点
**Java 语言具有以下特点：**
- **简单易学**：Java 的语法相对简洁清晰，与C++相比去掉了一些复杂的特性（如指针），使得初学者更容易上手。
- **面向对象**：Java 是一种纯粹的面向对象编程语言，支持封装、继承和多态等面向对象的特性，使得代码更加模块化和可扩展。
- **跨平台性**：Java 采用“**一次编写，到处运行**”的原则，通过Java虚拟机（JVM）实现跨平台的能力。程序只需编译一次，就可以在任何支持Java的操作系统上运行。
- **高性能**：虽然Java是解释执行的语言，但通过即时编译和优化技术，Java 可以达到接近于本地代码的性能水平。
- **安全性**：Java 提供了安全管理机制，可以对代码进行访问控制和权限限制，防止恶意程序对系统造成损害。
- **大型的标准类库**：Java 提供了丰富的类库，包含了很多常用的功能和工具，开发人员可以直接使用这些类库来加快开发速度。
- **多线程支持**：Java 内置支持多线程编程，提供了线程的创建、同步和管理等功能，便于开发多线程应用程序。
- **开源生态系统**：Java 拥有庞大的开源社区和丰富的第三方库，开发者可以轻松获取各种开源工具和框架，加快开发速度。

### 2.比较 JVM 和 JDK 以及 JRE
>**JVM（Java Virtual Machine）、JDK（Java Development Kit）和JRE（Java Runtime Environment）**是 Java 平台的三个重要组成部分，它们在开发和运行 Java 程序中扮演不同的角色。下面是对它们进行比较的解释：
>>**JVM（Java虚拟机）**：JVM 是 Java 程序的运行环境，它负责将编译后的 Java 字节码转换为机器码并执行。**JVM 提供了内存管理、垃圾回收、线程管理**等功能。由于Java是跨平台的语言，JVM 的存在使得 Java 程序可以在不同的操作系统上运行，因为每个操作系统都有相应的 JVM 实现。
**JDK（Java开发工具包）**：**JDK 是用于开发 Java 程序的软件包**，其中包含了编译器（javac）、调试器（jdb）、构建工具（javap、jar）、文档生成工具（javadoc）等一系列开发工具。除了这些工具，JDK 还包含了 JRE。开发人员使用 JDK 来编写、编译和调试 Java 程序。
**JRE（Java运行时环境）**：**JRE 是 JVM 所需的运行时环境**，它包含了 JVM 和 Java 类库（Java API），以及其他支持文件和配置。当用户想要运行一个已经编译好的 Java 程序时，只需安装 JRE，而不需要安装 JDK。JRE 使得用户可以在自己的计算机上运行 Java 应用程序，但没有了开发和调试程序的工具。
简单来说，**JVM 是运行 Java 程序的虚拟机，JDK 是开发 Java 程序所需的工具包，而 JRE 则是运行已编译的 Java 程序所需的环境**。在开发过程中，通常需要安装 JDK，而在用户想要运行 Java 程序时，只需安装 JRE。

### 3.为什么说 Java 语言“解释与编译并存”?
- Java 语言被称为“解释与编译并存”，是因为 Java 编程语言和它的运行环境（JVM）采用了一种独特的执行模型，结合了解释执行和编译执行的优点。
1.**解释执行**：Java 程序在运行之前首先会通过 Java 编译器将源代码编译成字节码文件（以 .class 文件形式存在），这些字节码文件并不直接在硬件上执行，而是由 JVM 中的解释器逐条解释执行。解释执行的好处是可以实现跨平台性，因为字节码是与特定硬件无关的中间格式。
2.**即时编译（Just-In-Time Compilation, JIT）：为了提高 Java 程序的执行效率**，JVM 在解释器的基础上引入了即时编译器。即时编译器会将经过多次执行的热点代码（Hotspot Code）转换成本地机器码，并进行缓存，以后再次执行该代码时直接使用本地机器码执行，避免了重复解释执行的开销。这种动态编译技术可以大幅度提高程序的执行速度。(emm，简单理解就是用的多的转为本地机器码之后直接用，方便快捷)
- 因此，**Java 程序在运行时会先经历编译阶段将源代码转换成字节码，然后在解释器中解释执行字节码**。同时，JVM 还会根据代码的执行情况使用即时编译器将热点代码转换成本地机器码，提高程序的运行效率。这种混合的执行模型使得 Java 兼具跨平台性和高性能的特点。

### 4..Java 基本类型有哪几种，各占多少位？
>Java 的基本类型有以下几种：(8位一字节)
>>**byte**：占用 8 位，取值范围为 -128 到 127。
**short**：占用 16 位，取值范围为 -32,768 到 32,767。
**int**：占用 32 位，取值范围为 -2,147,483,648 到 2,147,483,647。
**long**：占用 64 位，取值范围为 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807。
**float**：占用 32 位，可表示浮点数，精度约为 6-7 位有效数字。
**double**：占用 64 位，可表示双精度浮点数，精度约为 15 位有效数字。
**boolean**：占用 1 位，只能取值 true 或 false。
**char**：占用 16 位，用于表示 Unicode 字符。

### 5.Java 泛型，类型擦除
Java 泛型是 Java 语言中的一项特性，它允许我们在创建类、接口和方法时使用参数化类型。**通过使用泛型，可以实现代码的重用性和类型安全性。**

然而，Java 的泛型实现中存在类型擦除（Type Erasure）的机制。类型擦除指的是在编译时期擦除泛型的具体类型信息，并将泛型类型替换为其边界或 Object 类型。这意味着在编译后的字节码中，并不保留泛型的具体类型信息。

类型擦除的主要原因是为了与 Java 早期版本的二进制兼容性保持一致。在引入泛型之前，Java 使用原始类型（raw types）来表示集合等数据结构。为了确保现有的非泛型代码继续有效，Java 在编译阶段会将泛型代码擦除为原始类型，以便向后兼容。

尽管类型擦除导致在运行时无法获取泛型的具体类型信息，但在编译时仍然会执行类型检查，以确保类型安全性。此外，通过反射和辅助工具类（如 TypeToken），可以在一定程度上绕过类型擦除并获取泛型的信息。

### 6.== 和 equals() 的区别
- `==` 运算符：== 是一个关系运算符，用于比较两个对象的引用是否相等。当使用 == 比较两个对象时，它会检查这两个对象是否指向内存中的同一块地址。换句话说，它比较的是对象的身份标识，即对象在内存中的位置。

- `equals() `方法：equals() 是一个方法，定义在 java.lang.Object 类中。它用于比较两个对象的内容是否相等。默认情况下，equals() 方法和 == 运算符的行为是相同的，即比较对象的引用是否相等。但是，**它可以被子类重写以提供自定义的相等性比较逻辑。例如，String 类重写了 equals() 方法，用于比较字符串的内容而不是引用**。

在使用时，通常应遵循以下准则：
- 如果需要比较对象的引用，以确定它们是否指向同一块内存，使用 == 运算符。
- 如果需要比较对象的内容，即判断它们是否在逻辑上相等，应使用 equals() 方法。但要注意，当使用 equals() 方法时，需要确保该方法已经被适当地重写，以便进行正确的内容比较。
eg:
```java
String str1 = new String("Hello");
String str2 = new String("Hello");

System.out.println(str1 == str2);          // false，比较的是引用
System.out.println(str1.equals(str2));     // true，比较的是内容

Integer num1 = 5;
Integer num2 = 5;

System.out.println(num1 == num2);          // true，比较的是值（基本数据类型）
System.out.println(num1.equals(num2));     // true，比较的是内容
```

### 7.hashCode() 和 equals() 
hashCode() 和 equals() 方法在 Java 中经常一起使用，用于实现对象的相等性判断和集合类的正确操作。

`hashCode() `方法：hashCode() 是定义在 `java.lang.Object` 类中的方法，用于返回对象的哈希码值。哈希码是一个整数，由对象的内容计算得出。可以将哈希码视为对象的 "数字指纹"，用于快速确定对象是否可能相等。

- **如果两个对象通过 equals() 方法比较相等**，那么它们的 **hashCode() 值必须相同**（但反之不成立）。
- 如果**两个对象的 hashCode() 值相同，它们并不一定相等**。
在**重写 equals() 方法时，通常也需要重写 hashCode() 方法**，以确保满足上述规则。这是因为在使用基于哈希表的数据结构（如 HashSet、HashMap 等）时，它们依赖于 hashCode() 方法来进行对象的存储和查找。

### 8.为什么重写 equals() 时要重写 hashCode() 方法？
为什么需要重写 hashCode() 方法呢？**这是因为在使用基于哈希表的数据结构（如 HashSet、HashMap 等）时，它们依赖于 `hashCode() `方法来进行对象的存储和查找。哈希表通过计算对象的哈希码值并将其映射到特定位置来存储对象。当我们使用 `HashSet` 来判断对象是否已经存在集合中时，它会先计算对象的哈希码，然后根据哈希码来快速查找对象。**如果两个对象通过 equals() 方法比较相等，那么它们的哈希码值必须相同，否则 HashSet 就无法正确地定位到已有的对象。

如果你只重写了 equals() 方法而没有重写 hashCode() 方法，可能会导致以下问题：

- **违反了对象相等性原则**：根据 equals() 的逻辑，可能认为两个对象是相等的，但它们的哈希码却不同。这会导致在基于哈希表的集合类中出现错误的行为。
- **无法正确地查找对象**：当尝试从哈希表中查找一个对象时，由于哈希码不匹配，哈希表会认为该对象不存在，即使实际上已经存在。
因此，为了保持对象的一致性和正确操作哈希表数据结构，必须同时重写 equals() 和 hashCode() 方法。确保在两个方法中使用相同的属性来计算哈希码值，以满足相等的对象具有相等的哈希码这一要求。这样可以确保对象在集合类中的正确存储和查找。

### 9.重载和重写的区别
- 重载：在同一个类中定义多个同名方法，但参数列表不同，返回值也可以不同，可以通过不同的方法签名来区分它们。
- 重写：子类继承父类，并定义了与父类**相同名称、相同参数列表和相同返回类型**的方法。**修饰符范围必须比父类大或同**
例如，如果父类方法是 `protected `访问修饰符，子类可以选择使用 `protected` 或 `public` 来重写该方法。

**重载是静态的**，编译时决定调用哪个方法；**重写是动态的**，运行时根据对象的实际类型决定调用哪个方法。

### 10.
